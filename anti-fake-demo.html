<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>防伪层展示 Demo</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #wrap {
            padding: 10px;
            background: white;
            box-shadow: 0 0 6px rgba(0,0,0,0.2);
        }
        canvas {
            border: 1px solid #999;
            display: block;
        }
        button {
            margin-top: 10px;
            padding: 6px 12px;
            border: 1px solid #999;
            background: #fafafa;
            cursor: pointer;
        }
    </style>
</head>
<body>
<h2>防伪层效果展示（仅视觉）</h2>

<div id="wrap">
    <canvas id="securityCanvas" width="400" height="200"></canvas>
</div>
<button id="regen">重新生成</button>

<script>
    function drawSecurityLayer(canvas) {
        const ctx = canvas.getContext('2d');
        const w = canvas.width;
        const h = canvas.height;

        // 背景填充浅色
        ctx.fillStyle = "#f1f3f8";
        ctx.fillRect(0, 0, w, h);

        // 1. 生成随机小块噪声（颗粒感）
        const blockSize = 4;
        for (let y = 0; y < h; y += blockSize) {
            for (let x = 0; x < w; x += blockSize) {
                const gray = 210 + Math.floor(Math.random() * 40) - 20; // around 210 ±20
                ctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
                ctx.fillRect(x, y, blockSize, blockSize);
            }
        }

        // 2. 叠加几组倾斜细线（模仿底纹）
        ctx.globalAlpha = 0.7;
        for (let k = 0; k < 3; k++) {
            const angle = (Math.random() * 60 - 30) * Math.PI / 180; // -30°~30°
            const step = 8 + Math.random() * 10;
            ctx.save();
            ctx.translate(w / 2, h / 2);
            ctx.rotate(angle);
            ctx.strokeStyle = k === 0 ? "#87a8ff" : (k === 1 ? "#a0d3ff" : "#c7c9ff");
            ctx.lineWidth = 0.6;

            for (let y = -h; y < h; y += step) {
                ctx.beginPath();
                ctx.moveTo(-w, y);
                ctx.lineTo(w, y);
                ctx.stroke();
            }
            ctx.restore();
        }
        ctx.globalAlpha = 1;

        // 3. 随机画几条波浪线（guilloche风格简化版）
        for (let i = 0; i < 8; i++) {
            ctx.beginPath();
            const baseY = Math.random() * h;
            const amp = 5 + Math.random() * 10;
            const freq = 0.01 + Math.random() * 0.03;
            const phase = Math.random() * Math.PI * 2;

            ctx.strokeStyle = "rgba(80,120,200,0.6)";
            ctx.lineWidth = 0.5;

            for (let x = 0; x <= w; x++) {
                const y = baseY + amp * Math.sin(freq * x + phase);
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // 4. “微缩文字”效果（其实只是很小字）
        ctx.font = "6px sans-serif";
        ctx.fillStyle = "rgba(60,60,100,0.8)";
        const text = "SECURITY ● ANTI-COUNTERFEIT ● DEMO ";

        for (let row = 0; row < 5; row++) {
            const y = 20 + row * 30 + Math.random() * 6;
            let x = -Math.random() * 40;
            while (x < w) {
                ctx.fillText(text, x, y);
                x += ctx.measureText(text).width + 10;
            }
        }

        // 5. 边框
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 1;
        ctx.strokeRect(0.5, 0.5, w - 1, h - 1);
    }

    const canvas = document.getElementById("securityCanvas");
    const btn = document.getElementById("regen");

    function regen() {
        drawSecurityLayer(canvas);
    }

    regen();
    btn.addEventListener("click", regen);
</script>
</body>
</html>
